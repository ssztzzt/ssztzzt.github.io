<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远远不够嗨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ssztzzt.github.io/"/>
  <updated>2019-07-28T12:43:11.230Z</updated>
  <id>http://ssztzzt.github.io/</id>
  
  <author>
    <name>Tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java面试题91-100【转】</title>
    <link href="http://ssztzzt.github.io/java-ten/"/>
    <id>http://ssztzzt.github.io/java-ten/</id>
    <published>2019-07-28T09:30:35.000Z</published>
    <updated>2019-07-28T12:43:11.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="91-解释一下什么是-aop？"><a href="#91-解释一下什么是-aop？" class="headerlink" title="91. 解释一下什么是 aop？"></a>91. 解释一下什么是 aop？</h2><blockquote><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p></blockquote><h2 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92. 解释一下什么是 ioc？"></a>92. 解释一下什么是 ioc？</h2><blockquote><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。<br>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p></blockquote><h2 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93. spring 有哪些主要模块？"></a>93. spring 有哪些主要模块？</h2><blockquote><ul><li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring dao：Data Access Object 提供了JDBC的抽象层。</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</li></ul></blockquote><h2 id="94-spring-常用的注入方式有哪些？"><a href="#94-spring-常用的注入方式有哪些？" class="headerlink" title="94. spring 常用的注入方式有哪些？"></a>94. spring 常用的注入方式有哪些？</h2><blockquote><ul><li>setter 属性注入</li><li>构造方法注入</li><li>注解方式注入</li></ul></blockquote><h2 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95. spring 中的 bean 是线程安全的吗？"></a>95. spring 中的 bean 是线程安全的吗？</h2><blockquote><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul></blockquote><h2 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96. spring 支持几种 bean 的作用域？"></a>96. spring 支持几种 bean 的作用域？</h2><blockquote><p>spring 支持 5 种作用域，如下：</p><ul><li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li><li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li><li>Web 环境下的作用域：</li><li>request：每次 http 请求都会创建一个 bean；</li><li>session：同一个 http session 共享一个 bean 实例；</li><li>global-session：用于 portlet 容器，因为每个 portlet 有单独的<br>session，globalsession 提供一个全局性的 http session。<br>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</li></ul></blockquote><h2 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97. spring 自动装配 bean 有哪些方式？"></a>97. spring 自动装配 bean 有哪些方式？</h2><blockquote><ul><li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li><li>byName：它根据 bean 的名称注入对象依赖项。</li><li>byType：它根据类型注入对象依赖项。</li><li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li><li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li></ul></blockquote><h2 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98. spring 事务实现方式有哪些？"></a>98. spring 事务实现方式有哪些？</h2><blockquote><ul><li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li><li>编码方式：提供编码的形式管理和维护事务。</li></ul></blockquote><h2 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99. 说一下 spring 的事务隔离？"></a>99. 说一下 spring 的事务隔离？</h2><blockquote><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：<br>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；<br>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；<br>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；<br>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；<br>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p></blockquote><h2 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100. 说一下 spring mvc 运行流程？"></a>100. 说一下 spring mvc 运行流程？</h2><blockquote><ul><li>spring mvc 先将请求发送给 DispatcherServlet。</li><li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li><li>DispatcherServlet 再把请求提交到对应的 Controller。</li><li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li><li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li><li>视图对象负责渲染返回给客户端。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;91-解释一下什么是-aop？&quot;&gt;&lt;a href=&quot;#91-解释一下什么是-aop？&quot; class=&quot;headerlink&quot; title=&quot;91. 解释一下什么是 aop？&quot;&gt;&lt;/a&gt;91. 解释一下什么是 aop？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;aop
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题81-90【转】</title>
    <link href="http://ssztzzt.github.io/java-nine/"/>
    <id>http://ssztzzt.github.io/java-nine/</id>
    <published>2019-07-28T09:00:35.000Z</published>
    <updated>2019-07-28T12:38:08.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81. 简述 tcp 和 udp的区别？"></a>81. 简述 tcp 和 udp的区别？</h2><blockquote><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 &gt;udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：</p><ul><li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li><li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li><li>tcp 面向字节流，udp 面向报文；</li><li>tcp 数据传输慢，udp 数据传输快；</li></ul></blockquote><h2 id="82-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82. tcp 为什么要三次握手，两次不行吗？为什么？"></a>82. tcp 为什么要三次握手，两次不行吗？为什么？</h2><blockquote><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p></blockquote><h2 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83. 说一下 tcp 粘包是怎么产生的？"></a>83. 说一下 tcp 粘包是怎么产生的？</h2><blockquote><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li></ul></blockquote><h2 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84. OSI 的七层模型都有哪些？"></a>84. OSI 的七层模型都有哪些？</h2><blockquote><ul><li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li><li>数据链路层：负责建立和管理节点间的链路。</li><li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li><li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li><li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li><li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li><li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li></ul></blockquote><h2 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85. get 和 post 请求有哪些区别？"></a>85. get 和 post 请求有哪些区别？</h2><blockquote><ul><li>get 请求会被浏览器主动缓存，而 post 不会。</li><li>get 传递参数有大小限制，而 post 没有。</li><li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li></ul></blockquote><h2 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86. 如何实现跨域？"></a>86. 如何实现跨域？</h2><blockquote><p>实现跨域有以下几种方案：</p><ul><li>服务器端运行跨域 设置 CORS 等于 *；</li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域；</li></ul></blockquote><h2 id="87-说一下-JSONP-实现原理？"><a href="#87-说一下-JSONP-实现原理？" class="headerlink" title="87. 说一下 JSONP 实现原理？"></a>87. 说一下 JSONP 实现原理？</h2><blockquote><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。  </p></blockquote><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="88-说一下你熟悉的设计模式？"><a href="#88-说一下你熟悉的设计模式？" class="headerlink" title="88. 说一下你熟悉的设计模式？"></a>88. 说一下你熟悉的设计模式？</h2><blockquote><ul><li>单例模式：保证被创建一次，节省系统开销。</li><li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li><li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li><li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li></ul></blockquote><h2 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a>89. 简单工厂和抽象工厂有什么区别？</h2><blockquote><ul><li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li><li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li><li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li></ul></blockquote><h1 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h1><h2 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90. 为什么要使用 spring？"></a>90. 为什么要使用 spring？</h2><blockquote><ul><li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li><li>spring 提供了事务支持，使得事务操作变的更加方便。</li><li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li><li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;81-简述-tcp-和-udp的区别？&quot;&gt;&lt;a href=&quot;#81-简述-tcp-和-udp的区别？&quot; class=&quot;headerlink&quot; title=&quot;81. 简述 tcp 和 udp的区别？&quot;&gt;&lt;/a&gt;81. 简述 tcp 和 udp的区别？&lt;/h2&gt;&lt;bl
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题71-80【转】</title>
    <link href="http://ssztzzt.github.io/java-eight/"/>
    <id>http://ssztzzt.github.io/java-eight/</id>
    <published>2019-07-27T09:58:35.000Z</published>
    <updated>2019-07-28T12:31:03.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71. 如何避免 SQL 注入？"></a>71. 如何避免 SQL 注入？</h2><blockquote><ul><li>使用预处理 PreparedStatement。</li><li>使用正则表达式过滤掉字符中的特殊字符。</li></ul></blockquote><h2 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72. 什么是 XSS 攻击，如何避免？"></a>72. 什么是 XSS 攻击，如何避免？</h2><blockquote><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。</p></blockquote><h2 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73. 什么是 CSRF 攻击，如何避免？"></a>73. 什么是 CSRF 攻击，如何避免？</h2><blockquote><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：</p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。<br>异常</li></ul></blockquote><h2 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74. throw 和 throws 的区别？"></a>74. throw 和 throws 的区别？</h2><blockquote><ul><li>throw：是真实抛出一个异常。</li><li>throws：是声明可能会抛出一个异常。</li></ul></blockquote><h2 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75. final、finally、finalize 有什么区别？"></a>75. final、finally、finalize 有什么区别？</h2><blockquote><ul><li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li><li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li><li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li></ul></blockquote><h2 id="76-try-catch-finally-中哪个部分可以省略？"><a href="#76-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="76. try-catch-finally 中哪个部分可以省略？"></a>76. try-catch-finally 中哪个部分可以省略？</h2><blockquote><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p></blockquote><h2 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><blockquote><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p></blockquote><h2 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78. 常见的异常类有哪些？"></a>78. 常见的异常类有哪些？</h2><blockquote><ul><li>NullPointerException 空指针异常</li><li>ClassNotFoundException 指定类不存在</li><li>NumberFormatException 字符串转换为数字异常</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常<br>网络</li></ul></blockquote><h2 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79. http 响应码 301 和 302 代表的是什么？有什么区别？</h2><blockquote><p>301：永久重定向。<br>302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p></blockquote><h2 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80. forward 和 redirect 的区别？"></a>80. forward 和 redirect 的区别？</h2><blockquote><p>forward 是转发 和 redirect 是重定向：</p><ul><li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li><li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li><li>效率：forward 比 redirect 效率高。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;71-如何避免-SQL-注入？&quot;&gt;&lt;a href=&quot;#71-如何避免-SQL-注入？&quot; class=&quot;headerlink&quot; title=&quot;71. 如何避免 SQL 注入？&quot;&gt;&lt;/a&gt;71. 如何避免 SQL 注入？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题61-70【转】</title>
    <link href="http://ssztzzt.github.io/java-seven/"/>
    <id>http://ssztzzt.github.io/java-seven/</id>
    <published>2019-07-27T09:38:35.000Z</published>
    <updated>2019-07-28T12:26:37.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61. 为什么要使用克隆？"></a>61. 为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h2 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62. 如何实现对象克隆？"></a>62. 如何实现对象克隆？</h2><blockquote><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul></blockquote><h1 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63. 深拷贝和浅拷贝区别是什么？"></a>63. 深拷贝和浅拷贝区别是什么？</h1><blockquote><ul><li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li><li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。<br>Java Web</li></ul></blockquote><h2 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64. JSP 和 servlet 有什么区别？"></a>64. JSP 和 servlet 有什么区别？</h2><blockquote><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。<br>    servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p></blockquote><h2 id="65-JSP-有哪些内置对象？作用分别是什么？"><a href="#65-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="65. JSP 有哪些内置对象？作用分别是什么？"></a>65. JSP 有哪些内置对象？作用分别是什么？</h2><blockquote><p>JSP 有 9 大内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web 应用的配置对象；</li><li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li><li>exception：封装页面抛出异常的对象。</li></ul></blockquote><h2 id="66-说一下-JSP-的-4-种作用域？"><a href="#66-说一下-JSP-的-4-种作用域？" class="headerlink" title="66. 说一下 JSP 的 4 种作用域？"></a>66. 说一下 JSP 的 4 种作用域？</h2><blockquote><ul><li>page：代表与一个页面相关的对象和属性。</li><li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li><li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li><li>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul></blockquote><h2 id="67-session-和-cookie-有什么区别？"><a href="#67-session-和-cookie-有什么区别？" class="headerlink" title="67. session 和 cookie 有什么区别？"></a>67. session 和 cookie 有什么区别？</h2><blockquote><ul><li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li><li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li><li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li></ul></blockquote><h2 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68. 说一下 session 的工作原理？"></a>68. 说一下 session 的工作原理？</h2><blockquote><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p></blockquote><h2 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h2 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70. spring mvc 和 struts 的区别是什么？"></a>70. spring mvc 和 struts 的区别是什么？</h2><blockquote><ul><li>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</li><li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li><li>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</li><li>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;61-为什么要使用克隆？&quot;&gt;&lt;a href=&quot;#61-为什么要使用克隆？&quot; class=&quot;headerlink&quot; title=&quot;61. 为什么要使用克隆？&quot;&gt;&lt;/a&gt;61. 为什么要使用克隆？&lt;/h2&gt;&lt;p&gt;克隆的对象可能包含一些已经修改过的属性，而 new 出来
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题51-60【转】</title>
    <link href="http://ssztzzt.github.io/java-six/"/>
    <id>http://ssztzzt.github.io/java-six/</id>
    <published>2019-07-26T09:38:35.000Z</published>
    <updated>2019-07-28T12:22:50.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51. ThreadLocal 是什么？有哪些使用场景？"></a>51. ThreadLocal 是什么？有哪些使用场景？</h2><blockquote><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p></blockquote><h2 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52. 说一下 synchronized 底层实现原理？"></a>52. 说一下 synchronized 底层实现原理？</h2><blockquote><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p></blockquote><h2 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53. synchronized 和 volatile 的区别是什么？"></a>53. synchronized 和 volatile 的区别是什么？</h2><blockquote><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul></blockquote><h2 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54. synchronized 和 Lock 有什么区别？"></a>54. synchronized 和 Lock 有什么区别？</h2><blockquote><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul></blockquote><h2 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55. synchronized 和 ReentrantLock 区别是什么？"></a>55. synchronized 和 ReentrantLock 区别是什么？</h2><blockquote><ul><li>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</li><li>主要区别如下：</li><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>olatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul></blockquote><h2 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56. 说一下 atomic 的原理？"></a>56. 说一下 atomic 的原理？</h2><blockquote><ul><li>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>反射</li></ul></blockquote><h2 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57. 什么是反射？"></a>57. 什么是反射？</h2><blockquote><ul><li>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</li></ul></blockquote><h2 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58. 什么是 Java 序列化？什么情况下需要序列化？"></a>58. 什么是 Java 序列化？什么情况下需要序列化？</h2><blockquote><ul><li>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</li><li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul></blockquote><h2 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59. 动态代理是什么？有哪些应用？"></a>59. 动态代理是什么？有哪些应用？</h2><blockquote><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p></blockquote><h2 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60. 怎么实现动态代理？"></a>60. 怎么实现动态代理？</h2><blockquote><p>DK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的对象拷贝。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;51-ThreadLocal-是什么？有哪些使用场景？&quot;&gt;&lt;a href=&quot;#51-ThreadLocal-是什么？有哪些使用场景？&quot; class=&quot;headerlink&quot; title=&quot;51. ThreadLocal 是什么？有哪些使用场景？&quot;&gt;&lt;/a&gt;51. 
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题41-50【转】</title>
    <link href="http://ssztzzt.github.io/java-five/"/>
    <id>http://ssztzzt.github.io/java-five/</id>
    <published>2019-07-26T08:59:35.000Z</published>
    <updated>2019-07-28T12:22:34.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a>41. sleep() 和 wait() 有什么区别？</h2><blockquote><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li></ul></blockquote><h2 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42. notify()和 notifyAll()有什么区别？"></a>42. notify()和 notifyAll()有什么区别？</h2><blockquote><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p></blockquote><h2 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43. 线程的 run() 和 start() 有什么区别？"></a>43. 线程的 run() 和 start() 有什么区别？</h2><blockquote><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p></blockquote><h2 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44. 创建线程池有哪几种方式？"></a>44. 创建线程池有哪几种方式？</h2><blockquote><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li></ul></blockquote><h2 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45. 线程池都有哪些状态？"></a>45. 线程池都有哪些状态？</h2><blockquote><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul></blockquote><h2 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46. 线程池中 submit() 和 execute() 方法有什么区别？"></a>46. 线程池中 submit() 和 execute() 方法有什么区别？</h2><blockquote><ul><li>execute()：只能执行 Runnable 类型的任务。</li><li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li><li>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</li></ul></blockquote><h2 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47. 在 Java 程序中怎么保证多线程的运行安全？"></a>47. 在 Java 程序中怎么保证多线程的运行安全？</h2><blockquote><ul><li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li><li>手动锁 Java 示例代码如下：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">"获得锁"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">"释放锁"</span>);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48. 多线程中 synchronized 锁升级的原理是什么？"></a>48. 多线程中 synchronized 锁升级的原理是什么？</h2><blockquote><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p></blockquote><h2 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49. 什么是死锁？"></a>49. 什么是死锁？</h2><blockquote><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p></blockquote><h2 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50. 怎么防止死锁？"></a>50. 怎么防止死锁？</h2><blockquote><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;41-sleep-和-wait-有什么区别？&quot;&gt;&lt;a href=&quot;#41-sleep-和-wait-有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;41. sleep() 和 wait() 有什么区别？&quot;&gt;&lt;/a&gt;41. sleep() 和 w
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题31-40【转】</title>
    <link href="http://ssztzzt.github.io/java-four/"/>
    <id>http://ssztzzt.github.io/java-four/</id>
    <published>2019-07-25T08:00:35.000Z</published>
    <updated>2019-07-25T07:55:50.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a>31. 迭代器 Iterator 是什么？</h2><blockquote><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p></blockquote><h2 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a>32. Iterator 怎么使用？有什么特点？</h2><blockquote><p>Iterator 使用代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p></blockquote><h2 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a>33. Iterator 和 ListIterator 有什么区别？</h2><blockquote><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul></blockquote><h2 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a>34. 怎么确保一个集合不能被修改？</h2><blockquote><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35. 并行和并发有什么区别？"></a>35. 并行和并发有什么区别？</h2><blockquote><ul><li>并行：多个处理器或多核处理器同时处理多个任务。</li><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>如下图：<br><img src="1.png" alt></li><li>并发 = 两个队列和一台咖啡机。</li><li>并行 = 两个队列和两台咖啡机。</li></ul></blockquote><h2 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36. 线程和进程的区别？"></a>36. 线程和进程的区别？</h2><blockquote><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p></blockquote><h2 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37. 守护线程是什么？"></a>37. 守护线程是什么？</h2><blockquote><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p></blockquote><h2 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="38. 创建线程有哪几种方式？"></a>38. 创建线程有哪几种方式？</h2><blockquote><p>创建线程有三种方式：</p><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul></blockquote><h2 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="39. 说一下 runnable 和 callable 有什么区别？"></a>39. 说一下 runnable 和 callable 有什么区别？</h2><blockquote><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p></blockquote><h2 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40. 线程有哪些状态？"></a>40. 线程有哪些状态？</h2><blockquote><p>线程的状态：</p><ul><li>NEW 尚未启动</li><li>RUNNABLE 正在执行中</li><li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li><li>WAITING 永久等待状态</li><li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li><li>TERMINATED 执行完成</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;31-迭代器-Iterator-是什么？&quot;&gt;&lt;a href=&quot;#31-迭代器-Iterator-是什么？&quot; class=&quot;headerlink&quot; title=&quot;31. 迭代器 Iterator 是什么？&quot;&gt;&lt;/a&gt;31. 迭代器 Iterator 是什么？&lt;/h2
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题21-30【转】</title>
    <link href="http://ssztzzt.github.io/java-three/"/>
    <id>http://ssztzzt.github.io/java-three/</id>
    <published>2019-07-25T08:00:35.000Z</published>
    <updated>2019-07-25T07:47:11.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a>21. HashMap 和 Hashtable 有什么区别？</h2><blockquote><ul><li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul></blockquote><h2 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a>22. 如何决定使用 HashMap 还是 TreeMap？</h2><blockquote><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p></blockquote><h2 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a>23. 说一下 HashMap 的实现原理？</h2><blockquote><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p></blockquote><h2 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a>24. 说一下 HashSet 的实现原理？</h2><blockquote><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p></blockquote><h2 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a>25. ArrayList 和 LinkedList 的区别是什么？</h2><blockquote><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双&gt;- 向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li></ul></blockquote><h2 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a>26. 如何实现数组和 List 之间的转换？</h2><blockquote><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li><li>代码示例：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">"王磊"</span>);</span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"王磊"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure><h2 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a>27. ArrayList 和 Vector 的区别是什么？</h2><blockquote><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul></blockquote><h2 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a>28. Array 和 ArrayList 有何区别？</h2><blockquote><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul></blockquote><h2 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a>29. 在 Queue 中 poll()和 remove()有什么区别？</h2><blockquote><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li><li>代码示例：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">"string"</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure><h2 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a>30. 哪些集合类是线程安全的？</h2><blockquote><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-HashMap-和-Hashtable-有什么区别？&quot;&gt;&lt;a href=&quot;#21-HashMap-和-Hashtable-有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;21. HashMap 和 Hashtable 有什么区别？&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题11-20【转】</title>
    <link href="http://ssztzzt.github.io/java-tow/"/>
    <id>http://ssztzzt.github.io/java-tow/</id>
    <published>2019-07-24T09:50:35.000Z</published>
    <updated>2019-07-25T03:42:22.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><blockquote><ul><li><em>不需要，抽象类不一定非要有抽象方法。</em><br>示例代码：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out. println(<span class="string">"hi~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面代码，抽象类并没有抽象方法但完全可以正常运行。</strong></p><h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><blockquote><ol><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ol></blockquote><a id="more"></a><h2 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a>13. 抽象类能使用 final 修饰吗？</h2><blockquote><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p></blockquote><h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><blockquote><ol><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ol></blockquote><h2 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a>15. Java 中 IO 流分为几种？</h2><blockquote><ol><li>按功能来分：输入流（input）、输出流（output）。</li><li>按类型来分：字节流和字符流。</li><li>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符&gt;4. 流按 16 位传输以字符为单位输入输出数据。</li></ol></blockquote><h2 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h2><blockquote><ol><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简&gt;单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO 异步 IO 的操作基于事件和回调机制。</li></ol></blockquote><h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h2><blockquote><ol><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ol></blockquote><h2 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a>18. Java 容器都有哪些？</h2><p><strong>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示</strong></p><blockquote><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li></ul></li><li>Vector</li><li>Stack</li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul></blockquote><h2 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a>19. Collection 和 Collections 有什么区别？</h2><blockquote><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li></ul></blockquote><h2 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a>20. List、Set、Map 之间的区别是什么？</h2><blockquote><ul><li><strong>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</strong></li><li>三者之间的区别，如下表：<br><img src="1.png" alt></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;11-抽象类必须要有抽象方法吗？&quot;&gt;&lt;a href=&quot;#11-抽象类必须要有抽象方法吗？&quot; class=&quot;headerlink&quot; title=&quot;11. 抽象类必须要有抽象方法吗？&quot;&gt;&lt;/a&gt;11. 抽象类必须要有抽象方法吗？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;不需要，抽象类不一定非要有抽象方法。&lt;/em&gt;&lt;br&gt;示例代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cat&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System. out. println(&lt;span class=&quot;string&quot;&gt;&quot;hi~&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;上面代码，抽象类并没有抽象方法但完全可以正常运行。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;12-普通类和抽象类有哪些区别？&quot;&gt;&lt;a href=&quot;#12-普通类和抽象类有哪些区别？&quot; class=&quot;headerlink&quot; title=&quot;12. 普通类和抽象类有哪些区别？&quot;&gt;&lt;/a&gt;12. 普通类和抽象类有哪些区别？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;普通类不能包含抽象方法，抽象类可以包含抽象方法。&lt;/li&gt;
&lt;li&gt;抽象类不能直接实例化，普通类可以直接实例化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java面试题1-10【转】</title>
    <link href="http://ssztzzt.github.io/java-one/"/>
    <id>http://ssztzzt.github.io/java-one/</id>
    <published>2019-07-22T23:04:35.000Z</published>
    <updated>2019-07-25T07:41:14.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h2><blockquote><p>•    JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>•    JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p></blockquote><h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h2><blockquote><p>== 解读<br>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：<br>•    基本类型：比较的是值是否相同；<br>•    引用类型：比较的是引用是否相同；<br>代码示例：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。<br>equals 解读<br>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p></blockquote><a id="more"></a><h2 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h2><blockquote><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。<br>代码示例：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br><span class="line">执行的结果：</span><br><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><blockquote><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p></blockquote><h2 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a>4. final 在 Java 中有什么作用？</h2><p>•    final 修饰的类叫最终类，该类不能被继承。<br>•    final 修饰的方法不能被重写。<br>•    final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><h2 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a>5. Java 中的 Math. round(-1. 5) 等于多少？</h2><blockquote><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p></blockquote><h2 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h2><blockquote><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p></blockquote><h2 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><blockquote><p>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p></blockquote><h2 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”与 String str=new String(“i”)一样吗？"></a>8. String str=”i”与 String str=new String(“i”)一样吗？</h2><blockquote><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p></blockquote><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><blockquote><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br>// StringBuffer reverse<br>StringBuffer stringBuffer = new StringBuffer();<br>stringBuffer. append(“abcdefg”);<br>System. out. println(stringBuffer. reverse()); // gfedcba<br>// StringBuilder reverse<br>StringBuilder stringBuilder = new StringBuilder();<br>stringBuilder. append(“abcdefg”);<br>System. out. println(stringBuilder. reverse()); // gfedcba</p></blockquote><h2 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a>10. String 类的常用方法都有那些？</h2><blockquote><p>•    indexOf()：返回指定字符的索引。<br>•    charAt()：返回指定索引处的字符。<br>•    replace()：字符串替换。<br>•    trim()：去除字符串两端空白。<br>•    split()：分割字符串，返回一个分割后的字符串数组。<br>•    getBytes()：返回字符串的 byte 类型数组。<br>•    length()：返回字符串长度。<br>•    toLowerCase()：将字符串转成小写字母。<br>•    toUpperCase()：将字符串转成大写字符。<br>•    substring()：截取字符串。<br>•    equals()：字符串比较。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h1&gt;&lt;h2 id=&quot;1-JDK-和-JRE-有什么区别？&quot;&gt;&lt;a href=&quot;#1-JDK-和-JRE-有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;1. JDK 和 JRE 有什么区别？&quot;&gt;&lt;/a&gt;1. JDK 和 JRE 有什么区别？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;•    JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。&lt;br&gt;•    JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。&lt;br&gt;具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-和-equals-的区别是什么？&quot;&gt;&lt;a href=&quot;#2-和-equals-的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;2. == 和 equals 的区别是什么？&quot;&gt;&lt;/a&gt;2. == 和 equals 的区别是什么？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;== 解读&lt;br&gt;对于基本类型和引用类型 == 的作用效果是不同的，如下所示：&lt;br&gt;•    基本类型：比较的是值是否相同；&lt;br&gt;•    引用类型：比较的是引用是否相同；&lt;br&gt;代码示例：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String x = &lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String y = &lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String z = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(x==y); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(x==z); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(x.equals(y)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(x.equals(z)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。&lt;br&gt;equals 解读&lt;br&gt;equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。&lt;br&gt;首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cat&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cat c1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cat(&lt;span class=&quot;string&quot;&gt;&quot;王磊&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cat c2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cat(&lt;span class=&quot;string&quot;&gt;&quot;王磊&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(c1.equals(c2)); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; == obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;原来 equals 本质上就是 ==。&lt;br&gt;那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;老王&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String s2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;老王&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(s1.equals(s2)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object anObject)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; == anObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (anObject &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; String) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String anotherString = (String)anObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = value.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n == anotherString.value.length) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; v1[] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; v2[] = anotherString.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (n-- != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (v1[i] != v2[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。&lt;br&gt;总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试" scheme="http://ssztzzt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://ssztzzt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
